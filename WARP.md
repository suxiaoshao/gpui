# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

## Project Overview

This is a workspace containing multiple GPUI-based desktop applications. GPUI is a Rust UI framework from Zed Industries for building native, GPU-accelerated applications. The workspace contains four independent applications:

- **ai-chat**: An AI chatbot with conversation management, streaming responses, and WebAssembly extension support
- **feiwen**: A novel/web content reader application with database storage
- **http-client**: An HTTP request testing tool (similar to Postman)
- **novel-download**: A novel/web content downloading application

All apps share common workspace dependencies defined in the root `Cargo.toml`:
- `gpui` (0.2.2) - Core UI framework
- `gpui-component` (0.5.0) - Reusable UI components
- `gpui-component-assets` (0.5.0) - Bundled assets for components

## Commands

### Building and Running

```bash
# Build entire workspace
cargo build

# Build specific app
cargo build -p ai-chat
cargo build -p feiwen
cargo build -p http-client
cargo build -p novel-download

# Run specific app
cargo run -p ai-chat
cargo run -p feiwen
cargo run -p http-client
cargo run -p novel-download

# Development with auto-reload (requires cargo-watch)
cargo watch -x 'run -p ai-chat'
cargo watch -x 'run -p feiwen'
cargo watch -x 'run -p http-client'
cargo watch -x 'run -p novel-download'
```

### Testing

```bash
# Run all tests in workspace
cargo test

# Run tests for specific app
cargo test -p ai-chat
cargo test -p feiwen
cargo test -p http-client
cargo test -p novel-download

# Run specific test
cargo test -p ai-chat test_name
```

### Database Management (ai-chat only)

The `ai-chat` app uses Diesel ORM with SQLite. Database migrations are embedded in the binary and applied automatically on first run.

```bash
# Navigate to ai-chat directory
cd app/ai-chat

# Generate migrations (if diesel CLI is installed)
diesel migration generate migration_name

# Schema is auto-generated at: src/database/schema.rs
```

Database location:
- macOS: `~/Library/Application Support/top.sushao.ai-chat/history.sqlite3`
- Linux: `$XDG_CONFIG_HOME/top.sushao.ai-chat/history.sqlite3` or `~/.config/top.sushao.ai-chat/history.sqlite3`

### Extension Development (ai-chat only)

Extensions are WebAssembly components following the Component Model specification.

```bash
# Build extension (in extension directory, e.g., app/ai-chat/extensions/url_search)
cargo component build --release

# Extension location: app/ai-chat/extensions/
# Each extension needs:
# - extension.wasm (compiled WASM component)
# - config.toml (extension metadata)
```

## Architecture

### GPUI Application Structure

Each app follows a similar GPUI initialization pattern:

1. **Logging Setup**: Uses `tracing` and `tracing-subscriber` with dual output (file + console)
   - macOS logs: `~/Library/Logs/top.sushao.{app-name}/data.log`
   - Linux logs: `$XDG_DATA_HOME/top.sushao.{app-name}/logs/data.log`

2. **GPUI Application**: Created with `Application::new().with_assets(...)`

3. **Initialization**: Registers components, key bindings (Cmd-Q to quit), and opens main window

4. **Root View**: Each app uses `Root::new(view, window, cx)` from `gpui-component` as the top-level container

### ai-chat Architecture

The most complex app with the following key modules:

- **adapter/**: LLM provider implementations (OpenAI, streaming support)
- **database/**: Diesel ORM layer with SQLite
  - `model/`: Database models (SQL types)
  - `service/`: High-level API (converts between SQL and domain types)
  - `schema.rs`: Auto-generated by Diesel
  - `types/`: Domain types (Role, Status, Mode)
- **extensions/**: WebAssembly Component Model runtime
  - Uses `wasmtime` (v40) for WASM execution
  - Extensions defined by WIT files in `extensions/wit/`
  - Extensions can access HTTP client and selected text via host functions
- **views/**: UI layer
  - `home/`: Main view with sidebar and tabbed conversations
  - Components built using GPUI's reactive patterns
- **store.rs**: Application state management (ChatDataInner)
  - Manages conversations, folders, and tabs
  - Coordinates between database and UI
- **fetch.rs**: HTTP request handling for LLM streaming

**State Flow**: Database ← Service Layer ← Store (Global State) ← Views ← Components

### Extension System (ai-chat)

Extensions are WASM components that can intercept and modify chat requests/responses:

1. Host function imports: `get-selected-text`, `http-client` (defined in WIT)
2. Extension exports: `on-request`, `on-response` hooks
3. Extensions loaded from `app/ai-chat/extensions/` with config.toml metadata
4. Extension runner manages WASM store and execution lifecycle

### Common Patterns Across Apps

- **Error Handling**: Each app defines `{App}Error` and `{App}Result<T>` types using `thiserror`
- **Async Runtime**: Uses GPUI's built-in async executor (or tokio for ai-chat)
- **Action System**: Define actions with `actions!()` macro and register handlers with `cx.on_action()`
- **Key Bindings**: `cx.bind_keys([KeyBinding::new(...)])`
- **Window Management**: `cx.open_window(WindowOptions { ... }, |window, cx| { ... })`

## Code Organization Rules

### File Structure

- Each app is self-contained under `app/{app-name}/`
- Main entry point: `src/main.rs`
- Module structure exposed via `mod.rs` or re-exports in parent modules
- Tests are inline with `#[cfg(test)]` and `#[test]` attributes

### GPUI View Patterns

1. Views must implement `Render` trait
2. Use `cx.new(|cx| YourView::new(...))` to create view entities
3. Access global state via `cx.global::<T>()` (must implement `Global` trait)
4. Update state with `cx.set_global(...)` or `cx.update_global(|state, cx| ...)`
5. Subscribe to updates with `cx.subscribe(...)` or `cx.observe(...)`

### Database Patterns (ai-chat)

- SQL models are prefixed with `Sql` (e.g., `SqlConversation`)
- Service layer provides domain models (e.g., `Conversation`)
- Use connection pooling: `cx.global::<Db>().get()?`
- Migrations embedded via `include_str!()` for portability

### Async Patterns

- GPUI views use `spawn()` to run async tasks
- Use `cx.spawn(|this, mut cx| async move { ... })` for view-scoped async
- Background tasks use `cx.background_executor().spawn(...)`

## Development Environment

- **Rust Edition**: 2024
- **Required**: Rust 1.92+ (check with `cargo --version`)
- **Optional Tools**:
  - `cargo-watch`: For auto-reload during development
  - `diesel_cli`: For database migrations (install with `cargo install diesel_cli --no-default-features --features sqlite`)

## Platform-Specific Notes

### macOS
- App data: `~/Library/Application Support/top.sushao.{app-name}/`
- Logs: `~/Library/Logs/top.sushao.{app-name}/`
- Uses native window decorations with custom titlebar

### Linux
- App data: `$XDG_CONFIG_HOME/top.sushao.{app-name}/` or `~/.config/top.sushao.{app-name}/`
- Logs: `$XDG_DATA_HOME/top.sushao.{app-name}/logs/` or `~/.local/share/top.sushao.{app-name}/logs/`

### Dependencies
- All apps require system dependencies for GPUI (GPU drivers, windowing system)
- SQLite is bundled via `libsqlite3-sys` with `bundled-windows` feature
